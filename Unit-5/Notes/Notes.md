# Module 5: Programming in PHP and MySQL (16 hours)

## 5.1. PHP’s Place in the Web World, Basic Rules of PHP Programs, Uses of PHP

### 5.1.1. PHP’s Place in the Web World

*   **Definition of PHP:**
    PHP (a recursive acronym for "PHP: Hypertext Preprocessor") is a widely-used, open-source, **server-side scripting language** primarily designed for web development. It can be embedded directly into HTML.

*   **How it Works (Server-Side Scripting):**
    1.  A user's browser requests a web page (e.g., `index.php`) from a web server.
    2.  If the requested file has a `.php` extension, the web server (e.g., Apache, Nginx) passes the file to the **PHP interpreter**.
    3.  The PHP interpreter executes the PHP code within the file. This code might perform various tasks:
        *   Connect to databases (like MySQL) to fetch or store data.
        *   Process form submissions.
        *   Manage user sessions and cookies.
        *   Generate dynamic content based on conditions or data.
        *   Interact with the file system.
    4.  The PHP script outputs **HTML** (and potentially CSS and JavaScript) as a result of its execution.
    5.  The web server sends this generated HTML back to the user's browser.
    6.  The browser renders the HTML, displaying the web page. The user never sees the raw PHP code, only the resulting HTML output.

*   **PHP's Popularity and Market Share:**
    *   PHP has historically been one of the most popular server-side languages for web development.
    *   It powers a significant portion of the internet, including famous platforms like WordPress (which runs on PHP), Facebook (originally built heavily on PHP, now uses HHVM/Hack), Wikipedia, Drupal, Joomla, and many more.
    *   Its ease of learning, large community, extensive documentation, and wide availability on web hosting providers contribute to its popularity.

*   **Relationship with HTML, CSS, and JavaScript:**
    *   **PHP (Server-Side):** Handles logic, data processing, database interaction, and generates the initial HTML structure.
    *   **HTML (Structure):** The output of PHP is primarily HTML, which defines the content and structure of the web page.
    *   **CSS (Presentation):** Styles the HTML generated by PHP to control the visual appearance.
    *   **JavaScript (Client-Side Behavior):** Runs in the user's browser to add interactivity, manipulate the DOM after the page has loaded, make AJAX calls, etc., often working with the HTML structure provided by PHP.

*   **Advantages of PHP:**
    *   **Widely Available & Affordable Hosting:** Most web hosts support PHP, often at low costs.
    *   **Large Community & Extensive Documentation:** Easy to find help, tutorials, and libraries.
    *   **Relatively Easy to Learn:** Syntax is somewhat similar to C, Java, and Perl, making it accessible for many developers.
    *   **Good Database Integration:** Excellent support for various databases, especially MySQL.
    *   **Numerous Frameworks and CMSs:** Frameworks like Laravel, Symfony, CodeIgniter, and Content Management Systems (CMS) like WordPress, Drupal, Joomla streamline development.
    *   **Cross-Platform:** Runs on various operating systems (Windows, Linux, macOS).
    *   **Scalability:** While sometimes debated, PHP can be scaled for large applications with proper architecture and tools.

*   **Disadvantages/Criticisms of PHP (Historically, many have been addressed in modern PHP):**
    *   **Inconsistent Function Naming and Parameter Order:** A common historical complaint, though modern PHP has improved consistency.
    *   **Loose Typing:** Can lead to unexpected behavior if not handled carefully (though type declarations have been added in recent versions).
    *   **Security Concerns (if not coded carefully):** Like any language, poor coding practices can lead to vulnerabilities (e.g., SQL injection, XSS). Modern PHP and frameworks provide tools to mitigate these.
    *   **Perception:** Sometimes viewed as less "elegant" than languages like Python or Ruby by some developers, though modern PHP has made significant strides.

### 5.1.2. Basic Rules of PHP Programs

1.  **PHP Tags:**
    *   PHP code is embedded within HTML using special start and end tags. The PHP interpreter only executes code within these tags.
    *   **Standard Tags (Recommended):** `<?php ... ?>`
        ```php
        <?php
            // PHP code goes here
            echo "Hello from PHP!";
        ?>
        ```
    *   **Short Echo Tags (If `short_open_tag` is enabled in `php.ini`):** `<?= ... ?>`
        *   This is a shorthand for `<?php echo ... ?>`.
        *   Example: `<h1><?= $pageTitle ?></h1>` (equivalent to `<h1><?php echo $pageTitle; ?></h1>`)
    *   **Short Tags (Discouraged, requires `short_open_tag`):** `<? ... ?>` (Can conflict with XML processing instructions). **Avoid using these.**
    *   **ASP-style Tags (Discouraged, requires `asp_tags`):** `<% ... %>` **Avoid using these.**

2.  **Statements and Semicolons:**
    *   PHP statements are instructions that perform an action.
    *   Each simple PHP statement **must end with a semicolon (`;`)**.
    *   The closing PHP tag `?>` automatically implies a semicolon for the last statement before it, but it's good practice to include it explicitly.
    ```php
    <?php
        $name = "Alice"; // Statement 1
        echo "Hello, " . $name; // Statement 2 (semicolon often omitted if it's the last line before ?>)
    ?>
    ```
    ```php
    <?php
        $age = 30;
        echo $age; // Good practice to include semicolon
    ?>
    ```

3.  **Case Sensitivity:**
    *   **Variable names are case-sensitive:** `$myVar` and `$myvar` are different variables.
    *   **Constants (by convention, and true for user-defined constants) are case-sensitive:** `MY_CONSTANT` is different from `my_constant`.
    *   **Function names, class names, and built-in PHP keywords (e.g., `echo`, `if`, `else`, `while`, `class`, `function`) are NOT case-sensitive.** However, it's good practice to use consistent casing (e.g., lowercase for keywords, camelCase or PascalCase for functions/classes).
    ```php
    <?php
        $color = "Red";
        echo $color; // Outputs "Red"
        // echo $Color; // Error: Undefined variable $Color

        ECHO "Hello!"; // Works, but 'echo' is preferred
        myFunction(); // Works if myFunction or MyFunction or MYFUNCTION is defined
    ?>
    ```

4.  **Comments:**
    *   Used to add notes or explanations within the code that are ignored by the PHP interpreter.
    *   **Single-line comments:**
        *   `// This is a single-line comment`
        *   `# This is also a single-line comment (less common)`
    *   **Multi-line comments:**
        *   `/* This is a
           multi-line comment */`
    ```php
    <?php
        // This script greets the user
        $username = "Guest"; /* Store the username */
        echo "Welcome, " . $username . "!"; // Display greeting
    ?>
    ```

5.  **Whitespace:**
    *   Whitespace (spaces, tabs, newlines) is generally ignored by the PHP interpreter between statements and elements of expressions, except when it's part of a string.
    *   Proper indentation and use of whitespace make code much more readable.
    ```php
    <?php
        $x=10+5; // Works, but less readable
        $y = 20 + 3; // More readable
        echo
        "Hello"
        ; // Works, but not standard
    ?>
    ```

6.  **Embedding PHP in HTML:**
    *   You can switch between HTML and PHP modes multiple times within a single file.
    ```html
    <!DOCTYPE html>
    <html>
    <head>
        <title><?php echo "My PHP Page"; ?></title>
    </head>
    <body>
        <h1>Welcome</h1>
        <?php
            $isLoggedIn = true;
            if ($isLoggedIn) {
                echo "<p>You are logged in!</p>";
            } else {
                echo "<p>Please log in.</p>";
            }
        ?>
        <p>This is static HTML content.</p>
        <p>Current time: <?php echo date('H:i:s'); ?></p>
    </body>
    </html>
    ```

### 5.1.3. Uses of PHP

PHP is a versatile language, especially in the web domain.

1.  **Dynamic Website and Web Application Development (Primary Use):**
    *   Generating dynamic page content based on user input, database data, or other conditions.
    *   Creating interactive websites with user accounts, forums, e-commerce features, etc.
    *   Building Content Management Systems (CMS) like WordPress, Drupal, Joomla.
    *   Developing web-based APIs (Application Programming Interfaces) for mobile apps or other services to consume.

2.  **Server-Side Scripting (General):**
    *   Performing tasks on the server that don't necessarily involve direct web page output, such as:
        *   Processing data from forms.
        *   Managing files on the server (uploading, deleting, modifying).
        *   Sending emails.
        *   Interacting with databases to store, retrieve, update, and delete information.

3.  **Database Interaction:**
    *   PHP has excellent support for a wide range of databases, including:
        *   **MySQL/MariaDB (very common pairing)**
        *   PostgreSQL
        *   SQLite
        *   Microsoft SQL Server
        *   Oracle
        *   MongoDB (NoSQL)
    *   It provides extensions like PDO (PHP Data Objects) and MySQLi (MySQL Improved) for secure and efficient database communication.

4.  **Session and Cookie Management:**
    *   Tracking user activity across multiple pages using sessions (server-side data storage).
    *   Storing small pieces of information on the user's browser using cookies.

5.  **Form Handling:**
    *   Receiving and validating data submitted through HTML forms (`$_GET`, `$_POST` superglobals).
    *   Processing user input and performing actions based on it.

6.  **Image Processing:**
    *   PHP's GD library and Imagick extension allow for creating and manipulating images (resizing, cropping, watermarking, generating thumbnails).

7.  **Working with Files and Directories:**
    *   Reading, writing, creating, deleting, and modifying files and directories on the server.

8.  **Command-Line Scripting:**
    *   PHP can be run from the command line (CLI - Command Line Interface) to perform utility tasks, cron jobs, or other scripts without a web server.
    *   Example: `php myscript.php`

9.  **XML and JSON Processing:**
    *   Parsing and generating XML and JSON data, which are common formats for data exchange in web services and APIs.

10. **Regular Expressions:**
    *   PHP has powerful support for regular expressions (Perl-compatible, PCRE) for complex string searching and manipulation.

11. **Network Programming:**
    *   Opening network sockets, interacting with other protocols (e.g., FTP, LDAP).

**PHP's place is firmly as a dominant server-side technology that enables the creation of dynamic, database-driven web experiences. While other server-side languages exist (Python with Django/Flask, Ruby on Rails, Node.js), PHP remains a strong contender due to its history, ecosystem, and ease of deployment.**

---

## 5.2. Text, Numbers, Variables in PHP

### 5.2.1. Text (Strings) in PHP

*   **Definition:**
    A string is a sequence of characters used to represent text.
*   **Creating Strings:**
    There are several ways to define strings in PHP:
    1.  **Single Quotes (`'`):**
        *   The simplest way. The string is treated literally.
        *   Variables and most escape sequences (like `\n`, `\t`) are **not** interpreted (expanded) within single quotes, except for `\'` (to escape a literal single quote) and `\\` (to escape a literal backslash).
        *   **Example:**
            ```php
            $name = 'Alice';
            $message = 'Hello, $name! This is a new line: \n'; // $name and \n are treated as literal text
            echo $message; // Output: Hello, $name! This is a new line: \n
            echo 'It\'s a beautiful day.'; // Output: It's a beautiful day.
            ```
    2.  **Double Quotes (`"`):**
        *   Allows for **variable interpolation** (variables are replaced with their values) and interpretation of **escape sequences** (e.g., `\n` for newline, `\t` for tab, `\$` for a literal dollar sign, `\"` for a literal double quote).
        *   Slightly slower than single quotes due to the parsing involved.
        *   **Example:**
            ```php
            $name = "Bob";
            $age = 30;
            $greeting = "Hello, $name! You are $age years old.\nThis is a tab: \t Character.";
            echo $greeting;
            // Output:
            // Hello, Bob! You are 30 years old.
            // This is a tab:      Character.

            // Complex variable interpolation (use curly braces):
            $item = "book";
            echo "I have three {$item}s."; // Output: I have three books.
            // echo "This is a $sign_dollar sign."; // Error, $sign_dollar is not defined
            echo "This is a \$dollar sign.";   // Output: This is a $dollar sign.
            ```
    3.  **Heredoc Syntax (`<<<IDENTIFIER ... IDENTIFIER;`):**
        *   Useful for multi-line strings and when you need to include many double quotes or variables without excessive escaping.
        *   Behaves like double-quoted strings (variables and escape sequences are parsed).
        *   The opening identifier `<<<IDENTIFIER` must be followed by a newline. The closing identifier `IDENTIFIER;` must be on a new line by itself, with no whitespace before it (except for the semicolon, which is optional but good practice).
        *   **Example:**
            ```php
            $title = "My Article";
            $author = "Jane Doe";
            $content = <<<EOT
            This is the content of "$title".
            It was written by $author.
            This string can span multiple lines
            and use "quotes" without escaping.
            EOT; // Closing identifier must be at the start of the line
            echo $content;
            ```
    4.  **Nowdoc Syntax (`<<<'IDENTIFIER' ... IDENTIFIER;`):**
        *   Similar to heredoc, but behaves like single-quoted strings (no variable interpolation or escape sequence parsing, except for `\\`).
        *   The opening identifier must be enclosed in single quotes.
        *   **Example:**
            ```php
            $variable = "some value";
            $text = <<<'EOD'
            This is a Nowdoc string.
            Variables like $variable are NOT expanded.
            Escape sequences like \n are also not processed.
            EOD;
            echo $text;
            ```

*   **String Concatenation:**
    *   Joining strings together is done using the **dot operator (`.`)**.
    *   **Example:**
        ```php
        $firstName = "John";
        $lastName = "Doe";
        $fullName = $firstName . " " . $lastName; // "John Doe"
        echo "Welcome, " . $fullName . "!";      // "Welcome, John Doe!"
        ```

*   **Common String Functions (PHP has many!):**
    *   `strlen($string)`: Returns the length of a string.
    *   `strpos($haystack, $needle)`: Finds the position of the first occurrence of a substring in a string (case-sensitive). Returns `false` if not found.
    *   `stripos($haystack, $needle)`: Case-insensitive version of `strpos`.
    *   `substr($string, $start, $length)`: Returns a part of a string.
    *   `str_replace($search, $replace, $subject)`: Replaces all occurrences of the search string with the replacement string.
    *   `strtolower($string)`: Converts a string to lowercase.
    *   `strtoupper($string)`: Converts a string to uppercase.
    *   `ucfirst($string)`: Converts the first character of a string to uppercase.
    *   `ucwords($string)`: Converts the first character of each word in a string to uppercase.
    *   `trim($string, $characters)`: Strips whitespace (or other characters) from the beginning and end of a string. `ltrim()`, `rtrim()`.
    *   `explode($delimiter, $string)`: Splits a string into an array by a delimiter.
    *   `implode($glue, $array)`: Joins array elements into a string with a glue string.
    *   `htmlspecialchars($string)`: Converts special HTML characters to their entity equivalents (e.g., `<` to `<`). Important for preventing XSS when displaying user input.
    *   `nl2br($string)`: Inserts HTML line breaks (`<br>` or `<br />`) before all newlines in a string.
    *   `printf()`, `sprintf()`: For formatted string output.

### 5.2.2. Numbers in PHP

PHP supports two main types of numbers:

1.  **Integers:**
    *   **Definition:** Whole numbers, without a decimal point (e.g., -5, 0, 10, 1234).
    *   Can be specified in decimal (base 10), hexadecimal (base 16, prefixed with `0x`), octal (base 8, prefixed with `0`), or binary (base 2, prefixed with `0b`).
    *   The size of an integer depends on the platform (e.g., 32-bit or 64-bit), but PHP_INT_MAX and PHP_INT_MIN constants define the limits. If an integer exceeds these limits, it will be treated as a float.
    *   **Example:**
        ```php
        $age = 30;          // Decimal
        $hexValue = 0xFF;   // Hexadecimal (255 in decimal)
        $octalValue = 0755; // Octal (493 in decimal)
        $binaryValue = 0b1010; // Binary (10 in decimal)
        $negative = -100;
        ```

2.  **Floating-Point Numbers (Floats, Doubles, Real Numbers):**
    *   **Definition:** Numbers with a decimal point or numbers in exponential form (e.g., 3.14, -0.5, 1.2e3 (which is 1.2 * 10^3 = 1200), 7E-10).
    *   **Caution (IMP):** Floating-point numbers have limited precision and can sometimes lead to unexpected results when comparing them directly due to how they are stored internally. For financial calculations or situations requiring high precision, consider using the BCMath Arbitrary Precision Mathematics extension or the GMP extension.
    *   **Example:**
        ```php
        $price = 19.99;
        $pi = 3.14159;
        $scientific = 6.022e23; // Avogadro's number
        ```

*   **Numeric Strings:**
    *   PHP is loosely typed. If a string contains a valid numeric value, PHP will often automatically convert (coerce) it to a number when used in a numeric context (e.g., in arithmetic operations).
    *   **Example:**
        ```php
        $stringNumber = "100";
        $anotherNumber = 50;
        $sum = $stringNumber + $anotherNumber; // $sum will be 150 (integer)
        echo $sum;

        $stringFloat = "25.5";
        $result = $stringFloat * 2; // $result will be 51.0 (float)
        echo $result;
        ```
    *   However, it's good practice to explicitly cast strings to numbers if you intend to perform calculations, to avoid ambiguity: `(int)$stringNumber`, `(float)$stringFloat`.

*   **Common Number Functions:**
    *   `is_int($var)` or `is_integer($var)`: Checks if a variable is an integer.
    *   `is_float($var)` or `is_double($var)`: Checks if a variable is a float.
    *   `is_numeric($var)`: Checks if a variable is a number or a numeric string.
    *   `round($float, $precision)`: Rounds a float.
    *   `ceil($float)`: Rounds a number up to the nearest integer.
    *   `floor($float)`: Rounds a number down to the nearest integer.
    *   `abs($number)`: Returns the absolute (non-negative) value.
    *   `rand($min, $max)` or `mt_rand($min, $max)`: Generates a random integer (mt_rand is generally better).
    *   `number_format($number, $decimals, $dec_point, $thousands_sep)`: Formats a number with grouped thousands.

### 5.2.3. Variables in PHP

*   **Definition:**
    A variable is a container for storing information (values like text, numbers, arrays, objects, etc.). Variables in PHP are represented by a dollar sign (`$`) followed by the variable name.

*   **Rules for PHP Variable Names:**
    *   Must start with a dollar sign (`$`).
    *   The first character after the `$` must be a letter (a-z, A-Z) or an underscore (`_`).
    *   Subsequent characters can be letters, numbers, or underscores.
    *   Variable names are **case-sensitive** (`$name` and `$Name` are different variables).
    *   Cannot contain spaces.
    *   Cannot be PHP reserved keywords (like `$echo`, `$if` - though you can use `$Echo` because it's case-sensitive, it's bad practice).

*   **Assigning Values:**
    *   The assignment operator (`=`) is used to assign a value to a variable.
    *   The variable is on the left side, and the value (or expression) is on the right side.
    *   PHP is **dynamically typed**, meaning you don't need to declare the type of a variable before assigning a value. The type of the variable is determined by the type of the value assigned to it.
    *   **Example:**
        ```php
        $name = "Alice";         // $name is now a string
        $age = 25;             // $age is now an integer
        $price = 19.99;        // $price is now a float
        $isStudent = true;     // $isStudent is now a boolean
        $hobbies = ["reading", "coding"]; // $hobbies is now an array

        // Value can change, and so can the type (though changing types drastically is often not good practice)
        $myVar = 100;
        $myVar = "Now I'm a string";
        ```

*   **Uninitialized Variables:**
    *   Using a variable that has not been assigned a value will typically result in a **notice** (E_NOTICE level error) and the variable will behave as if it has a default value (e.g., `null`, `0` for numbers, empty string for strings, empty array for arrays, depending on context).
    *   It's good practice to always initialize variables before using them or check if they are set using `isset()`.
    *   **Example:**
        ```php
        // echo $undefinedVar; // PHP Notice: Undefined variable: undefinedVar
        $value = $undefinedVar + 5; // $value will likely be 5 (treating $undefinedVar as 0)
        ```

*   **Variable Scope (Reiteration from previous context, crucial here):**
    *   **Global Scope:** Variables declared outside any function are global and can (with caveats) be accessed anywhere.
    *   **Local Scope:** Variables declared inside a function are local to that function and cannot be accessed outside it.
    *   **Accessing Globals Inside Functions:** To use a global variable inside a function, you must either:
        1.  Use the `global` keyword: `global $myGlobalVar;`
        2.  Use the `$GLOBALS` superglobal array: `$GLOBALS['myGlobalVar']` (This array contains all global variables).
        ```php
        $globalMessage = "Hello from Global";

        function showMessage() {
            global $globalMessage; // Make global variable accessible
            echo $globalMessage . "<br>";

            echo $GLOBALS['globalMessage'] . " via GLOBALS array.<br>";

            $localMessage = "Hello from Local"; // Local variable
            echo $localMessage . "<br>";
        }
        showMessage();
        // echo $localMessage; // Error: Undefined variable $localMessage
        ```
    *   **Static Variables (within functions):**
        *   When a function completes, its local variables are usually destroyed.
        *   If you declare a variable within a function as `static`, it will retain its value between function calls. It's initialized only on the first call.
        ```php
        function counter() {
            static $count = 0; // Initialized only once
            $count++;
            echo $count . "<br>";
        }
        counter(); // 1
        counter(); // 2
        counter(); // 3
        ```

*   **Variable Variables (Dynamic Variable Names):**
    *   You can use the value of one variable as the name of another variable.
    *   Syntax: `$$variableName`
    *   Use with caution as it can make code harder to read and debug.
    *   **Example:**
        ```php
        $varName = "city";
        $$varName = "London"; // This is equivalent to $city = "London";
        echo $city;          // Outputs: London
        ```

*   **Constants:** (Related to variables, but their value cannot change)
    *   Defined using `define("CONSTANT_NAME", value, case_insensitive_boolean);` (case_insensitive is rarely used and deprecated).
    *   Or using `const CONSTANT_NAME = value;` (for class constants or, since PHP 5.6, global constants defined at the top level of a script). `const` is generally preferred for its readability and compile-time nature.
    *   By convention, constant names are usually uppercase.
    *   Constants are automatically global across the entire script.
    ```php
    define("SITE_URL", "https://www.example.com");
    const MAX_USERS = 100;

    echo SITE_URL;
    echo MAX_USERS;
    ```

---

## 5.3. Primitives, Operations, Expression and Control Statements

### 5.3.1. Primitives (Basic Data Types) in PHP

PHP supports several fundamental (primitive) data types:

1.  **Boolean (`bool`):**
    *   Represents two possible states: `true` or `false`.
    *   Case-insensitive (e.g., `TRUE`, `True`, `true` are all the same).
    *   Often used in conditional statements.
    *   **Falsy values** in PHP (values that convert to `false` in a boolean context):
        *   the boolean `false` itself
        *   the integer `0` (zero)
        *   the float `0.0` (zero)
        *   the empty string `""`, and the string `"0"`
        *   an array with zero elements (`[]` or `array()`)
        *   the special type `NULL` (including unset variables)
        *   SimpleXML objects created from empty tags
    *   All other values are considered **truthy**.
    *   **Example:**
        ```php
        $isLoggedIn = true;
        $hasPermission = false;
        if ($isLoggedIn) { /* ... */ }
        ```

2.  **Integer (`int`):**
    *   Whole numbers (positive, negative, or zero) without a decimal point.
    *   Already covered in section 5.2.2.
    *   **Example:** `$count = 10; $temperature = -5;`

3.  **Float (Floating-point number, also `double` or `real`):**
    *   Numbers with a decimal point or in exponential notation.
    *   Already covered in section 5.2.2.
    *   **Example:** `$price = 9.99; $scientificNotation = 1.5e3;`

4.  **String (`string`):**
    *   A sequence of characters.
    *   Already covered in section 5.2.1.
    *   **Example:** `$greeting = "Hello, World!"; $name = 'PHP';`

5.  **NULL:**
    *   A special data type that represents a variable with **no value**.
    *   A variable is `NULL` if:
        *   It has been assigned the constant `NULL`.
        *   It has not been set to any value yet (uninitialized).
        *   It has been `unset()`.
    *   `NULL` is case-insensitive (`null`, `Null`, `NULL` are the same).
    *   **Example:**
        ```php
        $noValue = NULL;
        $anotherVar; // Is also NULL (with a notice if accessed directly)
        if (is_null($noValue)) {
            echo "Variable has no value.";
        }
        ```

**Compound Types (Not primitives, but fundamental):**

6.  **Array (`array`):**
    *   An ordered map that can hold multiple values of various types, accessed by keys (which can be integers or strings). Covered in detail in 5.4.
    *   **Example:** `$colors = ["red", "green", "blue"]; $person = ["name" => "John", "age" => 30];`

7.  **Object (`object`):**
    *   An instance of a class, holding properties (data) and methods (functions). PHP has a full object-oriented programming model.
    *   **Example:** `$myCar = new Car();`

**Special Types:**

8.  **Resource:**
    *   A special variable holding a reference to an external resource (e.g., a database connection, an open file handle).
    *   You don't typically create resources directly but get them from specific functions (e.g., `fopen()`, `mysqli_connect()`).

9.  **Callable (`callable` type hint, since PHP 5.4):**
    *   A type that indicates a value can be called as a function. This can be a string with a function name, an array representing an object method or static class method, or an anonymous function (Closure).

**Type Juggling / Coercion:**
PHP is a loosely typed language, meaning it will often try to automatically convert (coerce) values from one type to another depending on the context of an operation.
```php
$numString = "5";
$result = $numString + 10; // $numString is coerced to integer 5, $result is 15 (int)

$boolVal = true;
echo $boolVal . " is true"; // $boolVal is coerced to string "1", output: "1 is true"


While convenient, this can sometimes lead to subtle bugs if not understood. Explicit type casting can be used for clarity: (int)$var, (string)$var, (bool)$var.

5.3.2. Operations (Operators)

PHP supports various operators, many of which are similar to those in C, Java, or JavaScript.

Arithmetic Operators: +, -, *, /, % (modulus), ** (exponentiation - PHP 5.6+).

$a = 10; $b = 3;
echo $a + $b; // 13
echo $a % $b; // 1
echo $a ** $b; // 1000
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Assignment Operators: =, +=, -=, *=, /=, %=, **=, .= (string concatenation assignment).

$x = 5;
$x += 3; // $x is now 8
$message = "Hello";
$message .= " World!"; // $message is now "Hello World!"
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Comparison Operators: == (equal, type coercion), === (identical, value AND type), != or <> (not equal, type coercion), !== (not identical), <, >, <=, >=.

Spaceship Operator (<=>) (PHP 7+):

Returns -1 if left is less than right, 0 if equal, 1 if left is greater than right.

echo 1 <=> 2; // -1
echo 2 <=> 2; // 0
echo 3 <=> 2; // 1
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

IMP: Always prefer === and !== for comparisons to avoid issues with type coercion unless you specifically need the loose comparison.

Logical Operators: and (or &&), or (or ||), xor, ! (not).

&& and || have higher precedence than and and or. It's common practice to use && and ||.

They exhibit short-circuit evaluation.

$isUser = true; $isAdmin = false;
if ($isUser && !$isAdmin) { echo "Regular user."; }
if ($isAdmin || $isSuperUser) { /* ... */ } // $isSuperUser might not be evaluated if $isAdmin is true
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Increment/Decrement Operators: ++$var (pre-increment), $var++ (post-increment), --$var, $var--.

$c = 5;
echo ++$c; // 6 (c is incremented, then its new value is echoed)
echo $c++; // 6 (current value of c is echoed, then c is incremented to 7)
echo $c;   // 7
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

String Concatenation Operator: . (dot)

$greeting = "Hello" . " " . "PHP!"; // "Hello PHP!"
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Array Operators:

+ (Union): Appends elements from the right-hand array to the left-hand array. If keys are the same, elements from the left array are kept.

== (Equality): true if arrays have the same key/value pairs (order doesn't matter for associative arrays).

=== (Identity): true if arrays have the same key/value pairs in the same order and are of the same types.

!= or <> (Inequality)

!== (Non-identity)

$arr1 = ["a" => 1, "b" => 2];
$arr2 = ["c" => 3, "d" => 4, "a" => 5];
$union = $arr1 + $arr2; // $union will be ["a"=>1, "b"=>2, "c"=>3, "d"=>4] ('a' from $arr1 is kept)
print_r($union);
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Type Operators:

instanceof: Checks if an object is an instance of a specific class or interface.

class MyClass {}
$obj = new MyClass();
if ($obj instanceof MyClass) { echo "Yes, it's MyClass"; }
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Bitwise Operators: & (and), | (or), ^ (xor), ~ (not), << (shift left), >> (shift right). (Less common in typical web scripting).

Error Control Operator (@):

When prepended to an expression, any error messages that might be generated by that expression will be suppressed.

Use with extreme caution (IMP): Suppressing errors can hide problems and make debugging very difficult. It's generally better to handle errors properly (e.g., with try...catch or by checking return values) than to suppress them.

Example (discouraged use): $file = @fopen("nonexistent.txt", "r");

Execution Operator (Backticks `):

Executes a shell command. The output of the command is returned.

Security Risk (IMP): Be extremely careful if using user input to construct the command, as it can lead to command injection vulnerabilities. Often disabled by hosting providers.

Example: $output =ls -l; echo "<pre>$output</pre>";

Conditional (Ternary) Operator (? :):

Shorthand for if...else.

Syntax: (condition) ? value_if_true : value_if_false;

Null Coalescing Operator (??) (PHP 7+):

Returns its first operand if it exists and is not NULL; otherwise, it returns its second operand.

Useful for setting default values for variables that might not be set.

$username = $_GET['user'] ?? 'guest'; // If $_GET['user'] is not set or is NULL, $username becomes 'guest'
echo $username;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Null Coalescing Assignment Operator (??=) (PHP 7.4+):

Assigns the right-hand operand to the left-hand operand only if the left-hand operand is NULL.

$options['color'] = $options['color'] ?? 'blue'; // Old way
$options['color'] ??= 'blue'; // New way with ??=
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Operator Precedence and Associativity:
PHP defines an order of precedence for operators (e.g., * and / before + and -). Parentheses () can be used to explicitly control the order of evaluation. Associativity determines how operators of the same precedence are grouped (left-to-right or right-to-left). Refer to the PHP manual for the full precedence table.

5.3.3. Expressions

Definition:
An expression in PHP is anything that evaluates to a value. It can be a literal value, a variable, a function call, an operation, or any combination of these that PHP can reduce to a single value.

Examples:

5 (literal value, expression evaluates to 5)

$myVariable (variable, expression evaluates to the value of $myVariable)

10 + 20 (operation, expression evaluates to 30)

$a * ($b - $c) (combination)

myFunction() (function call, expression evaluates to the return value of myFunction())

$x > $y (comparison, expression evaluates to true or false)

$name = "Alice" (assignment, this whole thing is also an expression that evaluates to the assigned value, "Alice")

Expressions are the building blocks of statements. A statement is typically an expression followed by a semicolon.

5.3.4. Control Statements (Control Flow)

Control statements determine the order in which PHP code is executed.

Conditional Statements: (Allow code to be executed based on conditions)

if Statement:

if (condition) {
    // code to execute if condition is true
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

if...else Statement:

if (condition) {
    // code if true
} else {
    // code if false
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

if...elseif...else Statement: (Note: elseif, not else if like in some languages, though else if with a space also works but is technically two separate statements).

if (condition1) {
    // code if condition1 is true
} elseif (condition2) {
    // code if condition1 is false and condition2 is true
} else {
    // code if all preceding conditions are false
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

switch Statement: (Compares an expression against multiple constant values)

switch (expression) {
    case value1:
        // code for value1
        break;
    case value2:
        // code for value2
        break;
    default:
        // code if no case matches
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Alternative Syntax for Control Structures (useful in templates):
PHP offers an alternative syntax for if, while, for, foreach, and switch that can be more readable when embedding PHP within HTML. It uses colons (:) instead of opening braces and specific end keywords (e.g., endif;, endwhile;).

<?php if ($userIsAdmin): ?>
    <p>Welcome, Admin!</p>
    <a href="#">Admin Panel</a>
<?php else: ?>
    <p>Welcome, User!</p>
<?php endif; ?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Looping Statements: (Allow code to be executed repeatedly)

for Loop: (For a known number of iterations)

for (initialization; condition; increment) {
    // code to repeat
}
// Example:
for ($i = 0; $i < 5; $i++) {
    echo "Iteration: $i <br>";
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

while Loop: (Repeats as long as a condition is true, checks condition before iteration)

while (condition) {
    // code to repeat
}
// Example:
$counter = 0;
while ($counter < 3) {
    echo "Counter: $counter <br>";
    $counter++;
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

do...while Loop: (Repeats as long as a condition is true, executes code at least once, checks condition after iteration)

do {
    // code to repeat
} while (condition);
// Example:
$num = 10;
do {
    echo "Number: $num <br>"; // Will print "Number: 10" once
    $num++;
} while ($num < 5);
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

foreach Loop: (Specifically for iterating over arrays and objects)

Syntax for arrays with values only:
foreach ($array as $value) { // code using $value }

Syntax for arrays with keys and values:
foreach ($array as $key => $value) { // code using $key and $value }

Example:

$colors = ["red", "green", "blue"];
foreach ($colors as $color) {
    echo "$color <br>";
}

$person = ["name" => "Dave", "age" => 40];
foreach ($person as $attribute => $data) {
    echo "$attribute: $data <br>";
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

break Statement:

Immediately terminates the execution of the current for, foreach, while, do...while, or switch statement.

Can take an optional numeric argument to specify how many nested enclosing structures it should break out of (e.g., break 2;).

continue Statement:

Skips the rest of the current iteration of a loop (for, foreach, while, do...while) and proceeds to the next iteration (or condition evaluation).

Can also take an optional numeric argument for nested loops.

return Statement: (Primarily used in functions)

Exits the current function and optionally returns a value to the caller.

If used in the global scope of a script, it terminates the script's execution.

require, include, require_once, include_once:

Used to include and evaluate the content of another PHP file into the current script.

require: If the file cannot be included (e.g., not found), it produces a fatal error (E_COMPILE_ERROR) and stops the script.

include: If the file cannot be included, it produces a warning (E_WARNING) and the script continues execution.

_once versions (require_once, include_once): Ensure the file is included only once, even if the statement is encountered multiple times. This prevents problems like redefining functions or classes.

Usage: Essential for organizing code into reusable modules, libraries, templates (headers, footers).

// header.php
// <?php echo "<header>My Website Header</header>"; >

// index.php
<?php
    include 'header.php'; // or require 'header.php';
    echo "<main>Page content here.</main>";
    include_once 'footer.php';
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

goto Operator: (Available, but highly discouraged as it often leads to unreadable and unmaintainable "spaghetti code")

Allows unconditional jumping to another part of the script marked by a label.

Importance of Control Statements (IMP): Control statements are fundamental to programming logic. They allow PHP scripts to make decisions, repeat actions, and manage the flow of execution, enabling the creation of complex and dynamic applications.

5.4. Array, Functions, Form Handling
5.4.1. Arrays in PHP

Definition:
An array in PHP is an ordered map that can hold multiple values of various types (integers, strings, booleans, other arrays, objects, etc.). Each value in an array is associated with a key (or index).

PHP arrays are very flexible and can be used as traditional indexed arrays, associative arrays (hash maps/dictionaries), or a mix of both.

Creating Arrays:

Using array() construct (older, still valid):

// Indexed array (keys are numeric, starting from 0 by default)
$numbers = array(10, 20, 30, 40);
$fruits = array("apple", "banana", "cherry");

// Associative array (keys are strings)
$person = array(
    "name" => "John Doe",
    "age" => 30,
    "city" => "New York"
);
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Using short array syntax [] (PHP 5.4+ - Recommended):

// Indexed array
$colors = ["red", "green", "blue"];

// Associative array
$book = [
    "title" => "The Great Gatsby",
    "author" => "F. Scott Fitzgerald",
    "year" => 1925
];

// Mixed array
$mixed = [10, "hello", "country" => "USA", true];
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Creating an empty array and adding elements:

$cars = []; // or $cars = array();
$cars[] = "Volvo"; // Adds "Volvo" with numeric index 0
$cars[] = "BMW";   // Adds "BMW" with numeric index 1
$cars["fast"] = "Ferrari"; // Adds "Ferrari" with string key "fast"
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Accessing Array Elements:

Use square brackets [] with the key (index or string).

Example:

$fruits = ["apple", "banana", "cherry"];
echo $fruits[0]; // Outputs: apple
echo $fruits[1]; // Outputs: banana

$person = ["name" => "Alice", "age" => 28];
echo $person["name"]; // Outputs: Alice
echo $person["age"];  // Outputs: 28

// If a key doesn't exist, accessing it will usually generate a PHP Notice.
// Use isset() or array_key_exists() to check first.
if (isset($person["city"])) {
    echo $person["city"];
} else {
    echo "City not set.";
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Modifying Array Elements:

Assign a new value to an existing key.

Example:

$colors = ["red", "green", "blue"];
$colors[1] = "yellow"; // Changes "green" to "yellow"
// $colors is now ["red", "yellow", "blue"]

$user = ["role" => "editor"];
$user["role"] = "admin"; // Changes role
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Adding Elements to an Array:

Indexed array (append): $array[] = $value; (PHP automatically assigns the next available numeric index).

Associative array: $array['new_key'] = $value;

Example:

$tasks = ["write report"];
$tasks[] = "send email"; // Appends
$tasks["urgent"] = "call client";
print_r($tasks);
/*
Array
(
    [0] => write report
    [1] => send email
    [urgent] => call client
)
*/
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Removing Array Elements:

Use unset($array['key']);

unset() removes the element and its key. For indexed arrays, the keys are not automatically re-indexed.

Example:

$letters = ['a', 'b', 'c', 'd'];
unset($letters[1]); // Removes 'b'
print_r($letters);
/*
Array
(
    [0] => a
    [2] => c
    [3] => d
)
*/
// To re-index a numeric array:
// $letters = array_values($letters);
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Looping Through Arrays:

foreach Loop (Most common and convenient):

// For values only
$fruits = ["apple", "orange", "grape"];
foreach ($fruits as $fruit) {
    echo $fruit . "<br>";
}

// For keys and values
$capitals = ["USA" => "Washington D.C.", "UK" => "London", "Japan" => "Tokyo"];
foreach ($capitals as $country => $city) {
    echo "The capital of $country is $city.<br>";
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

for Loop (for indexed arrays with contiguous numeric keys):

$numbers = [10, 20, 30, 40, 50];
$count = count($numbers); // Get array length
for ($i = 0; $i < $count; $i++) {
    echo $numbers[$i] . "<br>";
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Multi-dimensional Arrays:

Arrays that contain other arrays as elements.

Example:

$students = [
    ["name" => "Alice", "age" => 20, "major" => "CS"],
    ["name" => "Bob", "age" => 22, "major" => "Math"],
    ["name" => "Charlie", "age" => 21, "major" => "Physics"]
];

echo $students[1]["name"]; // Outputs: Bob (name of the second student)
echo $students[0]["major"]; // Outputs: CS

// Looping through a multi-dimensional array
foreach ($students as $student) {
    echo "Name: " . $student["name"] . ", Age: " . $student["age"] . "<br>";
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Common Array Functions (PHP has a rich set - IMP):

count($array): Returns the number of elements in an array.

is_array($var): Checks if a variable is an array.

in_array($needle, $haystack): Checks if a value exists in an array.

array_key_exists($key, $array): Checks if a key exists in an array.

array_keys($array): Returns all the keys of an array.

array_values($array): Returns all the values of an array (and re-indexes if numeric).

array_push($array, $value1, $value2...): Pushes one or more elements onto the end of an array (like $array[] = $value;).

array_pop($array): Pops the element off the end of an array.

array_shift($array): Shifts an element off the beginning of an array.

array_unshift($array, $value1, $value2...): Prepends one or more elements to the beginning of an array.

array_merge($array1, $array2, ...): Merges one or more arrays. For string keys, later values overwrite earlier ones. For numeric keys, values are appended and re-indexed.

array_slice($array, $offset, $length, $preserve_keys): Extracts a slice of an array.

sort($array), rsort($array): Sorts an array by values (ascending/descending), re-assigns numeric keys.

asort($array), arsort($array): Sorts an associative array by values, preserving keys.

ksort($array), krsort($array): Sorts an associative array by keys.

array_map($callback, $array1, ...): Applies a callback function to each element of one or more arrays.

array_filter($array, $callback, $flag): Filters elements of an array using a callback function.

array_reduce($array, $callback, $initial): Iteratively reduces an array to a single value using a callback function.

print_r($array) and var_dump($array): Useful for debugging and displaying the contents of an array in a human-readable format. var_dump() provides more detail including data types.

5.4.2. Functions in PHP

(PHP functions share many concepts with JavaScript functions, but with PHP-specific syntax and features.)

Definition:
A function is a block of reusable code that performs a specific task. Functions help in organizing code, reducing redundancy, and improving readability.

Defining Functions:

Syntax: function functionName($param1, $param2, ...) { // code to execute; return $value; // optional }

Function names are case-insensitive in PHP (but it's good practice to be consistent).

Parameters are variables listed inside the parentheses that receive values when the function is called.

Example:

function greetUser($name) {
    echo "Hello, $name!<br>";
}

function addNumbers($num1, $num2) {
    $sum = $num1 + $num2;
    return $sum; // Return the result
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Calling Functions:

To execute a function, you "call" it by its name followed by parentheses (), passing any required arguments.

Example:

greetUser("Alice"); // Calls the greetUser function
$total = addNumbers(10, 15); // Calls addNumbers and stores the returned value in $total
echo "Total is: $total <br>"; // Outputs: Total is: 25
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Parameters and Arguments:

Parameters: Variables in the function definition.

Arguments: Values passed to the function when it's called.

Default Argument Values: You can specify default values for parameters. If an argument for that parameter is not provided during the call, the default value is used. Defaulted parameters should generally come after non-defaulted parameters.

function setPower($value, $exponent = 2) { // $exponent defaults to 2
    return $value ** $exponent;
}
echo setPower(5);    // Outputs: 25 (5^2)
echo setPower(3, 3); // Outputs: 27 (3^3)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Type Hinting / Type Declarations (PHP 5+, expanded in PHP 7+ - IMP):

Allows you to specify the expected data type for parameters and function return values.

If a value of an incorrect type is passed (and strict types are not enabled), PHP will try to coerce it if possible. If declare(strict_types=1); is set at the top of the file, a TypeError will be thrown.

Helps catch errors early and makes function signatures clearer.

Supported types: int, float, bool, string, array, object, callable, iterable, class names, interface names, self, parent.

Return type declaration: function functionName(...): returnType { ... }

Nullable types (PHP 7.1+): ?typeName (e.g., ?string means string or null).

Union types (PHP 8.0+): typeName1|typeName2 (e.g., int|float).

declare(strict_types=1); // Enforce strict typing for this file

function multiply(int $a, float $b): float {
    return $a * $b;
}
echo multiply(5, 2.5); // 12.5

function processUser(?User $user): void { // void means no return value
    if ($user !== null) {
        // process $user
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Variable-length Argument Lists (Variadic Functions - PHP 5.6+):

Use the ... (splat) operator before a parameter name to make it accept a variable number of arguments, which are then available as an array.

function sumNumbers(...$numbers) {
    $total = 0;
    foreach ($numbers as $num) {
        $total += $num;
    }
    return $total;
}
echo sumNumbers(1, 2, 3, 4); // Outputs: 10
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Argument Spreading (PHP 5.6+):

Use ... when calling a function to unpack an array or Traversable object into individual arguments.

$values = [10, 20];
$sum = addNumbers(...$values); // Equivalent to addNumbers(10, 20)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Returning Values:

The return statement exits the function and sends a value back to the calling code.

A function can return any type of value, including arrays and objects.

If return is omitted or used without a value, the function returns NULL.

A function can have multiple return statements (e.g., in different branches of an if statement).

Variable Scope in Functions:

Variables declared inside a function are local to that function.

Global variables need to be explicitly imported using global $varName; or accessed via $GLOBALS['varName'].

static variables inside functions retain their value between calls.

Anonymous Functions (Closures - PHP 5.3+):

Functions without a name, often assigned to variables or passed as arguments to other functions (callbacks).

Can "capture" variables from their surrounding scope using the use keyword.

Example:

$greet = function($name) {
    echo "Hello, $name from an anonymous function!<br>";
};
$greet("Developer");

$message = "Global message";
$closureWithUse = function() use ($message) {
    echo "The captured message is: $message <br>";
};
$closureWithUse();
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Arrow Functions (PHP 7.4+):

A more concise syntax for anonymous functions.

Implicitly capture variables from the parent scope (no use keyword needed).

Can only contain a single expression, which is implicitly returned.

Syntax: fn(parameters) => expression;

Example:

$numbers = [1, 2, 3, 4];
$squaredNumbers = array_map(fn($n) => $n * $n, $numbers);
print_r($squaredNumbers); // Array ( [0] => 1 [1] => 4 [2] => 9 [3] => 16 )

$multiplier = 5;
$multiplyByFive = fn($value) => $value * $multiplier; // $multiplier is automatically captured
echo $multiplyByFive(10); // 50
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Built-in Functions: PHP provides a vast library of built-in functions for various tasks (string manipulation, array operations, math, date/time, file system, etc.).

5.4.3. Form Handling in PHP

PHP is commonly used to process data submitted from HTML forms.

HTML Form Basics (Recap):

<form action="process.php" method="post"> ... </form>

action: Specifies the PHP script that will handle the form data.

method:

GET: Form data is appended to the URL (e.g., process.php?name=John&age=30). Data is visible, limited length. Accessed in PHP via $_GET.

POST: Form data is sent in the HTTP request body (not visible in URL). Suitable for larger/sensitive data, file uploads. Accessed in PHP via $_POST.

Input fields must have a name attribute for their data to be sent and accessible in PHP.

PHP Superglobals for Form Data (IMP):
Superglobals are built-in variables that are always accessible in all scopes.

$_GET: An associative array of variables passed to the current script via URL parameters (query string). Used for data sent with method="get".

$_POST: An associative array of variables passed to the current script via the HTTP POST method. Used for data sent with method="post".

$_REQUEST: An associative array that by default contains the contents of $_GET, $_POST, and $_COOKIE. It's generally recommended to use $_GET or $_POST directly for clarity and security, as $_REQUEST can make it harder to determine the source of the data and might introduce security risks if not handled carefully.

$_FILES: An associative array of items uploaded to the current script via the HTTP POST method (when enctype="multipart/form-data" is used in the form).

Accessing Form Data in PHP:

The keys in the $_GET or $_POST arrays correspond to the name attributes of the form input fields.

Example:
HTML Form (myform.html):

<form action="process_form.php" method="post">
    <label for="username">Name:</label>
    <input type="text" id="username" name="username"><br><br>
    <label for="email">Email:</label>
    <input type="email" id="email" name="user_email"><br><br>
    <input type="submit" value="Submit">
</form>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Html
IGNORE_WHEN_COPYING_END

PHP Script (process_form.php):

<?php
// Check if the form was submitted using POST
if ($_SERVER["REQUEST_METHOD"] == "POST") {
    // Access submitted data (ALWAYS VALIDATE AND SANITIZE USER INPUT!)
    $name = $_POST['username'] ?? 'Not provided'; // Using null coalescing for default
    $email = $_POST['user_email'] ?? 'Not provided';

    echo "<h1>Form Data Received</h1>";
    echo "<p>Name: " . htmlspecialchars($name) . "</p>"; // htmlspecialchars to prevent XSS
    echo "<p>Email: " . htmlspecialchars($email) . "</p>";

} else {
    // If not a POST request, perhaps redirect or show an error
    echo "Please submit the form.";
}
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Checking if Form Data is Set (IMP):

Before accessing elements in $_GET or $_POST, it's crucial to check if they exist to avoid "Undefined index" notices.

Use isset() or the null coalescing operator (??).

if (isset($_POST['username']) && !empty(trim($_POST['username']))) {
    $username = trim($_POST['username']);
} else {
    $usernameError = "Username is required.";
}

// Using null coalescing (PHP 7+) for default values
$age = $_POST['age'] ?? null; // If 'age' isn't set, $age will be null
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Security Considerations (CRITICALLY IMP):
NEVER TRUST USER INPUT! Always validate and sanitize data received from forms before using it.

Validation: Check if the data is in the expected format, range, length, etc. (as discussed in client-side validation, but critically important on the server).

Sanitization/Escaping for Output (Preventing XSS - Cross-Site Scripting):

When displaying user-submitted data back on an HTML page, use functions like htmlspecialchars() to convert special HTML characters (like <, >, &, ") into their HTML entity equivalents. This prevents malicious scripts embedded in the input from being executed.

$comment = $_POST['comment']; // Potentially malicious: <script>alert('XSS')</script>
echo "<p>" . htmlspecialchars($comment, ENT_QUOTES, 'UTF-8') . "</p>";
// Output in HTML source: <p><script>alert('XSS')</script></p>
// Browser will display the script tags as text, not execute them.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Sanitization/Preparation for Database (Preventing SQL Injection):

When using user input in database queries, ALWAYS use prepared statements with placeholders (using PDO or MySQLi). This is the most effective way to prevent SQL injection attacks.

Do NOT directly concatenate user input into SQL strings.

Input can also be sanitized using functions like mysqli_real_escape_string() (for MySQLi when not using prepared statements, though prepared statements are better) or by type casting.

Handling Different Input Types:

Text, Email, Password, Textarea: Access via $_POST['name_attribute']. Trim whitespace: $value = trim($_POST['name_attribute']);.

Checkboxes:

Single checkbox: if (isset($_POST['agree_terms'])) { $agreed = true; } (Value is usually "on" or what's in value attribute if checked, not sent if unchecked).

Multiple checkboxes with same name (e.g., name="hobbies[]"): $_POST['hobbies'] will be an array if any are checked.

if (isset($_POST['hobbies']) && is_array($_POST['hobbies'])) {
    foreach ($_POST['hobbies'] as $hobby) {
        echo htmlspecialchars($hobby) . "<br>";
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Radio Buttons: $_POST['radio_group_name'] will contain the value of the selected radio button.

Select (Dropdown):

Single select: $_POST['select_name'] contains the value of the selected <option>.

Multiple select (e.g., name="colors[]"): $_POST['colors'] will be an array of selected values.

File Uploads ($_FILES):

Requires form enctype="multipart/form-data" and method="post".

$_FILES is a multi-dimensional associative array. For an input name="myFile":

$_FILES['myFile']['name']: Original name of the file on the client machine.

$_FILES['myFile']['type']: MIME type of the file (e.g., image/jpeg). Do not trust this for security; validate server-side.

$_FILES['myFile']['size']: Size of the file in bytes.

$_FILES['myFile']['tmp_name']: The temporary filename where the uploaded file is stored on the server. You need to move this file to a permanent location.

$_FILES['myFile']['error']: An error code associated with the upload (0 means no error).

Processing Uploads:

Check for upload errors ($_FILES['myFile']['error']).

Validate file type, size, etc. (server-side).

Use move_uploaded_file($_FILES['myFile']['tmp_name'], "/path/to/destination/new_filename.ext") to move the temporary file to a permanent, web-accessible (or secure non-accessible) location.

if (isset($_FILES['profile_image']) && $_FILES['profile_image']['error'] == UPLOAD_ERR_OK) {
    $uploadDir = 'uploads/';
    $fileName = basename($_FILES['profile_image']['name']); // Basic sanitization
    $targetPath = $uploadDir . $fileName;

    // Further validation (size, type - e.g., using finfo_file or checking extension) should be done here

    if (move_uploaded_file($_FILES['profile_image']['tmp_name'], $targetPath)) {
        echo "File uploaded successfully: " . htmlspecialchars($fileName);
    } else {
        echo "Error moving uploaded file.";
    }
} elseif (isset($_FILES['profile_image'])) {
    echo "Upload error code: " . $_FILES['profile_image']['error'];
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Sticky Forms (Re-populating Forms):

After form submission (especially if there are errors), it's good UX to re-populate the form fields with the data the user already entered.

In the HTML form, use PHP to echo the submitted values into the value attribute of input fields, or use selected for <option> and checked for radio/checkboxes.

Example:

<input type="text" name="username" value="<?php echo isset($_POST['username']) ? htmlspecialchars($_POST['username']) : ''; ?>">
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Html
IGNORE_WHEN_COPYING_END
5.5. Working with Databases: Organizing Data in a Database, Connecting to a Database Program, Creating a Table, CRUD Operations

PHP excels at interacting with databases, with MySQL/MariaDB being a very common combination.

5.5.1. Organizing Data in a Database (Relational Database Concepts)

Database (DB): An organized collection of structured information, or data, typically stored electronically in a computer system. Managed by a Database Management System (DBMS).

DBMS (Database Management System): Software that allows users to define, create, maintain, and control access to the database (e.g., MySQL, PostgreSQL, Oracle, SQL Server).

Relational Database: A type of database that stores and provides access to data points that are related to one another. Data is organized into tables.

Table (Relation):

A collection of related data entries, consisting of columns (fields/attributes) and rows (records/tuples).

Example: A users table might have columns like id, username, email, password, registration_date.

Column (Field/Attribute):

Represents a specific piece of information about each record in a table (e.g., the email column in the users table).

Each column has a data type (e.g., INT, VARCHAR, TEXT, DATE, BOOLEAN).

Row (Record/Tuple):

Represents a single entry or item in a table (e.g., one specific user's information).

Primary Key (PK - IMP):

A column (or set of columns) in a table whose values uniquely identify each row in that table.

Cannot contain NULL values.

Often an auto-incrementing integer (e.g., id INT AUTO_INCREMENT PRIMARY KEY).

Foreign Key (FK):

A column (or set of columns) in one table that refers to the primary key in another table.

Used to establish and enforce relationships between tables (e.g., a posts table might have a user_id foreign key referencing the id in the users table).

Relationships:

One-to-One: Each record in Table A relates to one record in Table B, and vice-versa.

One-to-Many: One record in Table A can relate to many records in Table B, but each record in Table B relates to only one record in Table A (e.g., one user can have many posts).

Many-to-Many: Many records in Table A can relate to many records in Table B. This usually requires a third "join" or "linking" table (e.g., students and courses).

SQL (Structured Query Language):

The standard language used to communicate with relational databases. Used to create, read, update, and delete data (CRUD operations), define database schema, and manage permissions.

Normalization:

The process of organizing data in a database to reduce redundancy and improve data integrity. Involves structuring tables and establishing relationships according to certain rules (normal forms like 1NF, 2NF, 3NF).

5.5.2. Connecting to a Database Program (MySQL Example)

PHP provides several ways to connect to MySQL databases. The two main modern methods are:

MySQLi (MySQL Improved Extension):

Specific to MySQL databases.

Supports procedural and object-oriented styles.

Offers features like prepared statements, transactions, multiple statements.

Connecting (Procedural Style):

<?php
$servername = "localhost"; // or your db host
$username = "your_db_username";
$password = "your_db_password";
$dbname = "your_database_name";

// Create connection
$conn = mysqli_connect($servername, $username, $password, $dbname);

// Check connection
if (!$conn) {
    die("Connection failed: " . mysqli_connect_error()); // Stop script and show error
}
echo "Connected successfully (MySQLi Procedural)!<br>";

// ... perform database operations ...

mysqli_close($conn); // Close connection when done
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Connecting (Object-Oriented Style):

<?php
$servername = "localhost";
$username = "your_db_username";
$password = "your_db_password";
$dbname = "your_database_name";

// Create connection
$conn = new mysqli($servername, $username, $password, $dbname);

// Check connection
if ($conn->connect_error) {
    die("Connection failed: " . $conn->connect_error);
}
echo "Connected successfully (MySQLi OOP)!<br>";

// ... perform database operations ...

$conn->close();
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

PDO (PHP Data Objects):

A more general database abstraction layer. It provides a consistent interface to access multiple types of databases (MySQL, PostgreSQL, SQLite, SQL Server, etc.) by using database-specific PDO drivers.

Only supports an object-oriented style.

Recommended for new projects if you might need to switch databases later or prefer a consistent API.

Offers features like prepared statements, transactions.

Connecting:

<?php
$servername = "localhost";
$username = "your_db_username";
$password = "your_db_password";
$dbname = "your_database_name";
$charset = "utf8mb4"; // Recommended charset

$dsn = "mysql:host=$servername;dbname=$dbname;charset=$charset";
$options = [
    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION, // Throw exceptions on errors
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,       // Fetch results as associative arrays
    PDO::ATTR_EMULATE_PREPARES   => false,                  // Use native prepared statements
];

try {
    $pdo = new PDO($dsn, $username, $password, $options);
    echo "Connected successfully (PDO)!<br>";

    // ... perform database operations ...

    $pdo = null; // Close connection by setting object to null
} catch (PDOException $e) {
    // die("Connection failed: " . $e->getMessage());
    throw new PDOException($e->getMessage(), (int)$e->getCode());
}
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Key PDO Attributes:

PDO::ATTR_ERRMODE: Controls error reporting. PDO::ERRMODE_EXCEPTION is highly recommended as it makes error handling cleaner with try...catch blocks.

PDO::ATTR_DEFAULT_FETCH_MODE: How results are returned (e.g., PDO::FETCH_ASSOC for associative arrays, PDO::FETCH_OBJ for objects).

PDO::ATTR_EMULATE_PREPARES: false tells PDO to use native prepared statements from the database driver, which is generally more secure.

Storing Connection Credentials (IMP):

Do NOT hardcode database credentials directly in your main scripts, especially if they are in a web-accessible directory.

Store them in a separate configuration file (e.g., config.php) outside the web root if possible, or use environment variables.

config.php example:

<?php
define('DB_HOST', 'localhost');
define('DB_USER', 'dbuser');
define('DB_PASS', 'dbpassword');
define('DB_NAME', 'mydb');
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Then in your connection script: require_once 'config.php'; $conn = new mysqli(DB_HOST, DB_USER, DB_PASS, DB_NAME);

5.5.3. Creating a Table (SQL CREATE TABLE statement)

SQL is used to define the structure of tables.

The CREATE TABLE statement is used for this.

Syntax:

CREATE TABLE table_name (
    column1_name data_type column_constraints,
    column2_name data_type column_constraints,
    ...
    PRIMARY KEY (column_name_for_pk),
    FOREIGN KEY (column_name_for_fk) REFERENCES another_table(pk_column_of_another_table),
    -- other constraints
);
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
SQL
IGNORE_WHEN_COPYING_END

Common Data Types in MySQL:

INT or INTEGER: Whole numbers.

VARCHAR(length): Variable-length string (up to length characters).

TEXT: For long strings of text.

DATE: Stores a date (YYYY-MM-DD).

DATETIME or TIMESTAMP: Stores date and time. TIMESTAMP has automatic update features.

DECIMAL(precision, scale): For exact fixed-point numbers (good for currency).

BOOLEAN or BOOL (often an alias for TINYINT(1)).

ENUM('val1', 'val2', ...): A string object that can have only one value, chosen from a list of allowed values.

Common Column Constraints:

NOT NULL: Ensures the column cannot have a NULL value.

UNIQUE: Ensures all values in the column are unique.

PRIMARY KEY: Designates the column(s) as the primary key.

AUTO_INCREMENT: For integer primary keys, automatically generates a new unique number for each new row.

DEFAULT value: Sets a default value for the column if no value is specified during insertion.

Example (Creating a users table in MySQL):

CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL, -- Store hashed passwords, never plain text
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    registration_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
SQL
IGNORE_WHEN_COPYING_END

Executing CREATE TABLE with PHP:
You would typically run this SQL query once, either directly via a MySQL client (like phpMyAdmin, MySQL Workbench) or through a PHP script.
PHP with MySQLi (OOP):

<?php
// ... (connection code from 5.5.2) ...
if ($conn) { // Check if connection was successful
    $sql = "CREATE TABLE IF NOT EXISTS products (
        product_id INT AUTO_INCREMENT PRIMARY KEY,
        product_name VARCHAR(100) NOT NULL,
        description TEXT,
        price DECIMAL(10, 2) NOT NULL,
        stock_quantity INT DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )";

    if ($conn->query($sql) === TRUE) {
        echo "Table 'products' created successfully or already exists.<br>";
    } else {
        echo "Error creating table: " . $conn->error . "<br>";
    }
    $conn->close();
}
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

PHP with PDO:

<?php
// ... (connection code from 5.5.2, $pdo object) ...
if ($pdo) {
    try {
        $sql = "CREATE TABLE IF NOT EXISTS categories (
            category_id INT AUTO_INCREMENT PRIMARY KEY,
            category_name VARCHAR(50) NOT NULL UNIQUE
        )";
        $pdo->exec($sql); // Use exec() for queries that don't return a result set
        echo "Table 'categories' created successfully or already exists.<br>";
    } catch (PDOException $e) {
        echo "Error creating table: " . $e->getMessage() . "<br>";
    }
    $pdo = null;
}
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END
5.5.4. CRUD Operations

CRUD stands for Create, Read, Update, and Delete. These are the four basic functions of persistent storage.

Using Prepared Statements (Highly Recommended for Security - IMP):
Prepared statements separate SQL logic from the data. This helps prevent SQL injection vulnerabilities and can improve performance for queries executed multiple times.

CREATE (Inserting Data - SQL INSERT INTO statement)

SQL: INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);

PHP with MySQLi (OOP Prepared Statement):

<?php
// ... (connection $conn) ...
$productName = "Laptop Pro";
$description = "High-performance laptop for professionals.";
$price = 1299.99;
$stock = 50;

// 1. Prepare the statement
$stmt = $conn->prepare("INSERT INTO products (product_name, description, price, stock_quantity) VALUES (?, ?, ?, ?)");

// 2. Bind parameters (s=string, d=double/float, i=integer, b=blob)
// The types in the first argument must match the types of the variables being bound.
$stmt->bind_param("ssdi", $productName, $description, $price, $stock);

// 3. Execute the statement
if ($stmt->execute()) {
    $last_id = $conn->insert_id; // Get the ID of the last inserted row (if AUTO_INCREMENT)
    echo "New record created successfully. Last inserted ID is: " . $last_id . "<br>";
} else {
    echo "Error inserting record: " . $stmt->error . "<br>";
}

// 4. Close the statement
$stmt->close();
$conn->close();
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

PHP with PDO (Prepared Statement):

<?php
// ... (connection $pdo) ...
$categoryName = "Electronics";

try {
    // 1. Prepare (using named placeholders or ?)
    // Using named placeholders:
    $sql = "INSERT INTO categories (category_name) VALUES (:cat_name)";
    $stmt = $pdo->prepare($sql);

    // 2. Bind parameters (can be done in execute array or separately)
    // Method 1: Bind in execute array
    $stmt->execute([':cat_name' => $categoryName]);
    // Method 2: Bind separately (useful if reusing statement with different values)
    // $stmt->bindParam(':cat_name', $categoryName, PDO::PARAM_STR);
    // $stmt->execute();

    $last_id = $pdo->lastInsertId(); // Get last inserted ID
    echo "New category created successfully. ID: " . $last_id . "<br>";

} catch (PDOException $e) {
    echo "Error inserting category: " . $e->getMessage() . "<br>";
}
$pdo = null;
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

READ (Selecting Data - SQL SELECT statement)

SQL: SELECT column1, column2, ... FROM table_name WHERE condition ORDER BY column_name LIMIT count;

PHP with MySQLi (OOP Prepared Statement):

<?php
// ... (connection $conn) ...
$minPrice = 500.00;

$stmt = $conn->prepare("SELECT product_id, product_name, price FROM products WHERE price > ? ORDER BY price DESC");
$stmt->bind_param("d", $minPrice);
$stmt->execute();

// Get result set
$result = $stmt->get_result();

if ($result->num_rows > 0) {
    echo "<h2>Products over $$minPrice:</h2><ul>";
    // Fetch data row by row as an associative array
    while ($row = $result->fetch_assoc()) {
        echo "<li>ID: " . $row["product_id"] . " - Name: " . htmlspecialchars($row["product_name"]) . " - Price: $" . $row["price"] . "</li>";
    }
    echo "</ul>";
} else {
    echo "No products found matching criteria.<br>";
}
$stmt->close();
$conn->close();
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

PHP with PDO (Prepared Statement):

<?php
// ... (connection $pdo) ...
$searchKeyword = "%laptop%"; // For LIKE clause

try {
    $sql = "SELECT category_id, category_name FROM categories WHERE category_name LIKE :keyword";
    $stmt = $pdo->prepare($sql);
    $stmt->execute([':keyword' => $searchKeyword]);

    // Fetch all results at once as an array of associative arrays
    $categories = $stmt->fetchAll(); // Default fetch mode set in DSN (PDO::FETCH_ASSOC)

    if ($categories) {
        echo "<h2>Found Categories:</h2><ul>";
        foreach ($categories as $category) {
            echo "<li>ID: " . $category["category_id"] . " - Name: " . htmlspecialchars($category["category_name"]) . "</li>";
        }
        echo "</ul>";
    } else {
        echo "No categories found.<br>";
    }
} catch (PDOException $e) {
    echo "Error fetching categories: " . $e->getMessage() . "<br>";
}
$pdo = null;
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Fetching methods with PDO:

$stmt->fetch(): Fetches the next row.

$stmt->fetchAll(): Fetches all remaining rows.

$stmt->fetchColumn(): Fetches a single column from the next row.

UPDATE (Modifying Data - SQL UPDATE statement)

SQL: UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;

PHP with MySQLi (OOP Prepared Statement):

<?php
// ... (connection $conn) ...
$newPrice = 999.99;
$productIdToUpdate = 1; // Assuming product with ID 1 exists

$stmt = $conn->prepare("UPDATE products SET price = ? WHERE product_id = ?");
$stmt->bind_param("di", $newPrice, $productIdToUpdate);

if ($stmt->execute()) {
    if ($stmt->affected_rows > 0) {
        echo "Record updated successfully.<br>";
    } else {
        echo "No record found to update or data was the same.<br>";
    }
} else {
    echo "Error updating record: " . $stmt->error . "<br>";
}
$stmt->close();
$conn->close();
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

PHP with PDO (Prepared Statement):

<?php
// ... (connection $pdo) ...
$newCategoryName = "Updated Electronics";
$categoryIdToUpdate = 1;

try {
    $sql = "UPDATE categories SET category_name = :new_name WHERE category_id = :id";
    $stmt = $pdo->prepare($sql);
    $stmt->execute([
        ':new_name' => $newCategoryName,
        ':id' => $categoryIdToUpdate
    ]);

    if ($stmt->rowCount() > 0) { // rowCount() returns number of affected rows
        echo "Category updated successfully.<br>";
    } else {
        echo "No category found to update or data was the same.<br>";
    }
} catch (PDOException $e) {
    echo "Error updating category: " . $e->getMessage() . "<br>";
}
$pdo = null;
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

DELETE (Removing Data - SQL DELETE FROM statement)

SQL: DELETE FROM table_name WHERE condition;

PHP with MySQLi (OOP Prepared Statement):

<?php
// ... (connection $conn) ...
$productIdToDelete = 3;

$stmt = $conn->prepare("DELETE FROM products WHERE product_id = ?");
$stmt->bind_param("i", $productIdToDelete);

if ($stmt->execute()) {
    if ($stmt->affected_rows > 0) {
        echo "Record deleted successfully.<br>";
    } else {
        echo "No record found to delete.<br>";
    }
} else {
    echo "Error deleting record: " . $stmt->error . "<br>";
}
$stmt->close();
$conn->close();
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

PHP with PDO (Prepared Statement):

<?php
// ... (connection $pdo) ...
$categoryIdToDelete = 2;

try {
    $sql = "DELETE FROM categories WHERE category_id = :id";
    $stmt = $pdo->prepare($sql);
    $stmt->execute([':id' => $categoryIdToDelete]);

    if ($stmt->rowCount() > 0) {
        echo "Category deleted successfully.<br>";
    } else {
        echo "No category found to delete.<br>";
    }
} catch (PDOException $e) {
    echo "Error deleting category: " . $e->getMessage() . "<br>";
}
$pdo = null;
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Error Handling (IMP):

Always check the return values of database operations.

For MySQLi, check $conn->error or $stmt->error.

For PDO, when PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION is set, database errors will throw PDOExceptions, which should be caught using try...catch blocks. This is generally the cleaner way to handle errors.

5.6. Cookies and Session Tracking

Cookies and sessions are mechanisms used to store information about a user across multiple page requests, enabling personalized experiences and stateful web applications.

5.6.1. Cookies

Definition:
A cookie is a small piece of data that a web server sends to a user's web browser. The browser may store it (usually on the user's computer) and then send it back to the same server with subsequent requests.

Purpose:

Remembering User Information: Login status, user preferences (e.g., theme, language), shopping cart items.

Tracking User Behavior: For analytics, personalized advertising (though this has privacy implications and is increasingly regulated).

Session Management (less common for primary session ID storage now, sessions are better): Can store a session identifier.

How Cookies Work:

Server Sends Cookie: When a user visits a site, the server can send a cookie to the browser via the Set-Cookie HTTP header in its response.

Browser Stores Cookie: The browser stores the cookie according to its domain, path, expiration, and security settings.

Browser Sends Cookie Back: On subsequent requests to the same domain (and matching path, etc.), the browser automatically includes the relevant cookies in the Cookie HTTP header of the request.

Server Reads Cookie: The server-side script (e.g., PHP) can then access the cookie data.

Creating Cookies in PHP (setcookie() function):

setcookie(name, value, expire, path, domain, secure, httponly);

name (string): The name of the cookie.

value (string, optional): The value of the cookie. If set to an empty string or false, the cookie will be deleted (if other parameters match).

expire (int, optional): The timestamp (Unix timestamp - seconds since Jan 1 1970) when the cookie should expire.

If set to 0 or omitted, the cookie expires at the end of the browser session (when the browser closes). This is a "session cookie."

To set a "persistent cookie" for a future time: time() + (86400 * 30) (for 30 days; 86400 = 1 day in seconds).

To delete a cookie, set its expiration time to a time in the past: time() - 3600.

path (string, optional): The path on the server where the cookie will be available. / means the entire domain.

domain (string, optional): The domain that the cookie is available to (e.g., .example.com for subdomains).

secure (bool, optional): If true, the cookie will only be transmitted over a secure HTTPS connection. Recommended for sensitive cookies.

httponly (bool, optional): If true, the cookie will not be accessible via client-side JavaScript (document.cookie). Highly recommended to prevent XSS attacks from stealing cookies.

IMP: setcookie() must be called before any HTML output is sent by the script (before <!DOCTYPE>, <html>, or any echo). This is because it modifies HTTP headers.

Example:

<?php
// Set a cookie named "username" with value "JohnDoe" that expires in 30 days
$cookie_name = "username";
$cookie_value = "JohnDoe";
$expiration_time = time() + (86400 * 30); // 86400 = 1 day
$path = "/"; // Available on the entire domain

setcookie($cookie_name, $cookie_value, $expiration_time, $path);

// Set a secure, httponly cookie
setcookie("session_token", "abc123xyz", time() + 3600, "/", "", true, true);

// To delete a cookie (must use same path, domain etc. as when it was set)
// setcookie("username", "", time() - 3600, "/");
?>
<!DOCTYPE html>
<html>
<head><title>Cookies</title></head>
<body>
    <?php
    if (isset($_COOKIE['username'])) {
        echo "Welcome back, " . htmlspecialchars($_COOKIE['username']) . "!";
    } else {
        echo "Welcome, guest!";
    }
    ?>
</body>
</html>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Accessing Cookies in PHP ($_COOKIE superglobal):

$_COOKIE is an associative array containing the values of cookies sent by the browser to the script.

The keys are the cookie names.

IMP: Cookies are available in $_COOKIE on subsequent page loads after they have been set by the server and sent back by the browser. You cannot set a cookie and immediately read it from $_COOKIE in the same script execution.

Example (from above):

if (isset($_COOKIE['username'])) {
    $user = htmlspecialchars($_COOKIE['username']); // Sanitize for display
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Limitations and Considerations:

Size Limit: Browsers impose limits on the size of individual cookies (around 4KB) and the total number of cookies per domain.

User Control: Users can disable, view, or delete cookies in their browser settings.

Security: Cookies can be stolen via XSS if not HttpOnly, or intercepted if not Secure over HTTPS. Do not store highly sensitive information directly in cookies.

Privacy: Use of tracking cookies is subject to privacy regulations (e.g., GDPR, CCPA).

5.6.2. Session Tracking

Definition:
A session provides a way to store user information on the server for use across multiple page requests. Instead of storing data directly in the browser (like cookies do), a unique session ID is typically stored in a cookie (or passed in the URL, though less secure) to identify the user's session on subsequent requests.

Purpose:

Maintain user state (e.g., login status, user preferences, shopping cart content).

Store temporary information related to a user's interaction with the website.

More secure for storing sensitive information than client-side cookies because the actual data resides on the server.

How Sessions Work in PHP:

Start Session: When a session needs to be started or an existing one resumed, session_start() is called. This function must be called at the very beginning of your script, before any output is sent to the browser.

Session ID Generation/Retrieval:

If it's a new session (or no valid session cookie is found), PHP generates a unique Session ID (a long random string).

PHP then sends this Session ID to the browser, typically as a cookie (named PHPSESSID by default).

If a valid Session ID cookie is received from the browser, PHP uses that ID to retrieve the existing session data from the server.

Session Data Storage: Session data is stored on the server. The default storage mechanism is usually files (in a temporary directory on the server), but this can be configured to use databases or memory-based systems like Memcached or Redis for better scalability.

Accessing Session Data ($_SESSION superglobal):

Once session_start() is called, you can store and retrieve data using the $_SESSION superglobal associative array.

$_SESSION['key'] = 'value'; (to store data)

$data = $_SESSION['key']; (to retrieve data)

Saving Session Data: PHP automatically saves the contents of the $_SESSION array when the script finishes executing (or when session_write_close() is called).

Destroying a Session:

session_unset(): Frees all session variables currently registered.

session_destroy(): Destroys all data registered to a session. This also deletes the session file on the server. It does not unset the $_SESSION global variable itself, nor does it unset the session cookie in the browser.

To fully end a session:

session_start();
$_SESSION = array(); // Unset all session variables
if (ini_get("session.use_cookies")) { // If cookies are used for session ID
    $params = session_get_cookie_params();
    setcookie(session_name(), '', time() - 42000, // Set cookie to expire in past
        $params["path"], $params["domain"],
        $params["secure"], $params["httponly"]
    );
}
session_destroy(); // Destroy the session data on the server
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Using Sessions in PHP:
HTML/PHP (login.php - sets session):

<?php
session_start(); // Start the session at the very beginning

if ($_SERVER["REQUEST_METHOD"] == "POST") {
    // Basic example: assume login is successful
    $username_from_form = $_POST['username'] ?? 'Guest';

    $_SESSION['loggedin_user'] = $username_from_form;
    $_SESSION['login_time'] = time();

    header("Location: profile.php"); // Redirect to another page
    exit; // Important to exit after a header redirect
}
?>
<!DOCTYPE html>
<html>
<head><title>Login</title></head>
<body>
    <form method="post" action="login.php">
        Username: <input type="text" name="username"><br>
        Password: <input type="password" name="password"><br>
        <input type="submit" value="Login">
    </form>
</body>
</html>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

HTML/PHP (profile.php - reads session):

<?php
session_start(); // Must start session on every page that uses session variables

if (isset($_SESSION['loggedin_user'])) {
    $user = htmlspecialchars($_SESSION['loggedin_user']);
    $loginTime = date('Y-m-d H:i:s', $_SESSION['login_time']);
    echo "<h1>Welcome, $user!</h1>";
    echo "<p>You logged in at: $loginTime</p>";
    echo '<p><a href="logout.php">Logout</a></p>';
} else {
    echo "<h1>Access Denied</h1>";
    echo "<p>You are not logged in. Please <a href='login.php'>login</a>.</p>";
}
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

HTML/PHP (logout.php - destroys session):

<?php
session_start();

// Unset all of the session variables
$_SESSION = array();

// If it's desired to kill the session, also delete the session cookie.
// Note: This will destroy the session, and not just the session data!
if (ini_get("session.use_cookies")) {
    $params = session_get_cookie_params();
    setcookie(session_name(), '', time() - 42000,
        $params["path"], $params["domain"],
        $params["secure"], $params["httponly"]
    );
}

// Finally, destroy the session.
session_destroy();

echo "You have been logged out successfully.<br>";
echo "<a href='login.php'>Login again</a>";
?>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
PHP
IGNORE_WHEN_COPYING_END

Session Configuration Options (php.ini or ini_set()):

session.save_path: Where session files are stored.

session.name: Name of the session cookie (default PHPSESSID).

session.cookie_lifetime: Lifetime of the session cookie (0 for browser session).

session.cookie_secure: Send session cookie only over HTTPS. Set to On for production.

session.cookie_httponly: Make session cookie accessible only via HTTP protocol (not JavaScript). Set to On for production.

session.use_only_cookies: Prevents session IDs from being passed in URLs (more secure). Set to On for production.

session.gc_maxlifetime: How long (in seconds) unused session data is kept before being garbage collected.

Cookies vs. Sessions (Key Differences - IMP):

Feature	Cookies	Sessions
Storage	Client-side (user's browser/computer)	Server-side (session data on server)
Data Stored	Small amounts of text data (e.g., preferences, identifiers)	Can store complex data (arrays, objects)
ID Mechanism	The cookie itself is the data.	Stores a Session ID (often in a cookie) which points to server-side data.
Security	Less secure for sensitive data, can be viewed/modified by user, vulnerable to XSS if not HttpOnly.	More secure for sensitive data as actual data is on the server. Session ID can still be hijacked.
Size Limit	Small (around 4KB per cookie, ~20-50 cookies per domain)	Limited by server resources (disk space, memory).
Accessibility	Accessible via HTTP headers and client-side JS (unless HttpOnly).	Session data only accessible via server-side script ($_SESSION).
Expiration	Can be set to persist for long periods or expire with browser session.	Typically expires after a period of inactivity on the server or when browser closes (if session cookie is a session cookie).
User Control	Users can easily delete/block cookies.	Users can delete the session ID cookie, effectively ending their session. They cannot directly access/delete server-side session data.
Performance	Sending cookie data with every request adds minor overhead.	Server lookup of session data adds minor overhead. Storage mechanism (file, DB, Memcached) impacts performance.

When to Use Which:

Cookies: For non-sensitive data, user preferences that can be stored client-side, remembering "remember me" login tokens (securely generated), tracking (with consent).

Sessions: For sensitive data, user login state, shopping carts, temporary multi-step form data, any stateful information that needs to be securely maintained across requests.

Session Security Best Practices (IMP):

Use HTTPS: Always use HTTPS to encrypt communication, including the session ID cookie.

Regenerate Session ID: Call session_regenerate_id(true) after login and other sensitive state changes (e.g., privilege escalation) to prevent session fixation attacks. The true argument deletes the old session file.

Set Secure Cookie Flags: Configure session.cookie_secure = On, session.cookie_httponly = On, and session.use_only_cookies = On in php.ini or via session_set_cookie_params().

Short Session Timeout: Configure appropriate session.gc_maxlifetime and session.cookie_lifetime.

Destroy Sessions on Logout: Properly destroy session data and the session ID cookie.

Validate User Agent / IP (Optional, with caveats): For extra security, you could store the user's IP address or User-Agent string in the session and verify it on subsequent requests. However, this can cause issues for users with dynamic IPs or roaming devices.

IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END